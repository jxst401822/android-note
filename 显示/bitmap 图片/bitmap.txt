参见：
Android Training - 高效地显示Bitmap(Lesson 4 - 优化Bitmap的内存使用)
	http://hukai.me/android-training-displaying-bitmaps-efficiently-lesson-4/
mycsdn/那个大图片
	避免oom
	decodestream
		option
			sampleinsize
	lrucache
	decoderesource
用bitmap.recycle，并不是那么的straightforward
	http://blog.csdn.net/qlsusu/article/details/7836036

加载（参见：BitmapTool#getBitmapXXX）：
使用BitmapFactory#decodeStream来进行加载
InputStream的来源：
	如果图片来自于assets：AssetManager#open
	如果图片来自于res：Resources#openRawResource
		注意：需要设置options.inDensity和inTargetDensity，才能和BitmapFactory#decodeResource的效果一致，如：
		//该图片位于哪个density目录下（如：drawable-xxhdpi，则对应了480）
        options.inDensity = 480;
        options.inTargetDensity = getApplication().getResources().getDisplayMetrics().densityDpi;

尺寸
通过decodeResource()来加载的图片，会进行缩放（当bitmapfactory.options.inScaled为true时（默认为true））
缩放比例：inTargetDensity / inDensity
	如果图片被放入了drawable下，则inDensity为160（默认值），如果被放入了drawable-xxhdpi中，则inDensity为480
	也可以自定义inDensity
		BitmapFactory.Options options = new BitmapFactory.Options();
		options.inJustDecodeBounds = false;
		options.inSampleSize = 1;
		//该图片位于哪个density目录下（如：drawable-xxhdpi，则对应了480）
		options.inDensity = 160;
		options.inTargetDensity = 160;
		bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.origin, options);
		// MX4上，虽然density = 3
		// 但是通过设置inTargetDensity / inDensity = 160 / 160 = 1
		// 解码后图片大小为 图片的原始大小
--
系统也提供了方法
Bitmap scaledBitmap = Bitmap.createScaledBitmap(originBitmap,
	dstWidth,
	dstHeight,
	true);
--
另外一种解释
	BitmapDrawable，其尺寸由getIntrinsicWidth和getIntrinsicHeight给出，
	其值由：bitmap的尺寸（size），在哪个drawable文件下（sdensity），手机自身的dpi（tdensity） 来决定
		公式：尺寸=( (size * tdensity) + (sdensity >> 1) ) / sdensity;  
	在创建对象时，请使用带resource参数的构造函数，否则，认为targetDpi为默认160
	参见：http://blog.csdn.net/jason_wks/article/details/8283224

裁剪
使用mode
	// 准备画笔
	Paint paint = new Paint();
	paint.setAntiAlias(true);

	// 准备裁剪的矩阵
	Rect rect = new Rect(0, 0,
			originBitmap.getWidth(), originBitmap.getHeight());
	//或者：
	//RectF rectF = new RectF(new Rect(0, 0,
	//		originBitmap.getWidth(), originBitmap.getHeight()));

	//将图片画到一个独立的canvas上（从一个bitmap来）
	Bitmap roundBitmap = Bitmap.createBitmap(originBitmap.getWidth(),
			originBitmap.getHeight(), Bitmap.Config.ARGB_8888);
	Canvas canvas = new Canvas(roundBitmap);
	// 圆角矩阵，radius为圆角大小
	canvas.drawRoundRect(rectF, radius, radius, paint);
	// 关键代码，关于Xfermode和SRC_IN请自行查阅
	paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
	canvas.drawBitmap(originBitmap, rect, rect, paint);
	//之后将roundBitmap绘制到 源canvas上

如果是矩形，使用现成方法
	Bitmap clipBitmap = Bitmap.createBitmap(originBitmap,
		left, top,
		clipWidth, clipHeight);

方法：
decodestream
参见：com.oooo3d.lib.util.OtherTool.getBitmap(Context, int)

缓存：
lrucache
参见：my/talkingtom中 com.oooo3d.lib.util.ImageCache

释放：
参见：
	com.ql.tool.BitmapTool.recycleBitmap(Bitmap...)
	http://blog.csdn.net/arui319/article/details/7953690
从3.0开始，Bitmap像素数据和Bitmap对象一起存放在Dalvik堆中，而在3.0之前，Bitmap像素数据存放在Native内存中。则在3.0之后，不需要再调用recycle()

缩略图
理解ThumbnailUtils
	http://www.jayfeng.com/2016/03/16/%E7%90%86%E8%A7%A3ThumbnailUtils/
